小顶堆方法

struct cmp {
    bool operator() (const int& a, const int& b) {
        return a>b;
    }
};
class Solution {
public:
    vector<int> smallestK(vector<int>& arr, int k) {
        vector<int> ret;
        priority_queue<int> ans;
        for (auto e:arr) {
            ans.push(e);
            if(ans.size()>k) ans.pop();
        }
        
        int cnt = k;
        stack<int> ss;
        while (cnt--) {
            ss.push(ans.top());
            ans.pop();
        }
        while (ss.size()) {
            ret.push_back(ss.top());
            ss.pop();
        }
        return ret;
    }
};

中位数的中位数（快搜找出第K大，再遍历）
class Solution {
public:
    vector<int> smallestK(vector<int>& arr, int k) {
    vector<int>ans(k);
    if(k == 0)
        return ans;
    nth_element(arr.begin(),arr.begin() + k - 1,arr.end());
    int count= 0;
    for(int i = 0; i< arr.size(); i++){
        if(arr[i]<arr[k-1])
            ans[count++] = arr[i];
    }
    for(int i = count; i < k; i++)
        ans[i] = arr[k-1];
    return ans;
    }
};

快排思想

class Solution {
public:

    int partition(vector<int>& arr, int left, int right) {
        int p = arr[right];
        int i = left, j = right-1;
        while (true) {
            while (arr[i]<p && i <=right) i++;
            while (arr[j]>p && j>=0) j--;
            if (i>j) break;
            swap(arr[i],arr[j]);
            i++;
            j--;
        }
        swap(arr[i],arr[right]);
        return i;
        }
    vector<int> smallestK(vector<int>& arr, int k) {
        vector<int> ans;
        if (k==0) return ans;
        if (k==arr.size()) return arr;
        int left = 0, right = arr.size()-1;
        int index = partition(arr,left,right);
        bool flag = false;
        while (left <= right) {
            if (index== k-1) {
                flag = true;
                ans = vector(arr.begin(),arr.begin()+k);
                return ans;
            }
            else if (index < k-1) {
                left = index+1;
                index = partition(arr,left, right);
            }
            else {
                right = index-1;
                index = partition(arr,left,right);
            }
        }
        return vector(arr.begin(),arr.begin()+k);
    }
};
